**高并发学习**

////有很多是自己理解的，需要深入去学习，很多需要去看资料学习
- I/O调用：
    * I：read
        * 当调用read系统调用的时候，通过DMA（Direct Memory Access）将数据copy到内核模式
        * 然后由CPU控制将内核模式数据copy到用户模式的buffer中
    * O：write
        * write调用首先将用户模式下的buffer中的数据copy到内核模式下的socket buffer中
        * 最后通过DMA copy将内核模式的socket buffer的数据copy到网卡设备中

- I/O的阻塞和阻塞：用户线程调用内核IO操作时的用户线程的状态
    * 阻塞：在调用内核IO时，用户线程会挂起，直到调用返回到用户空间才继续执行
    * 非阻塞：调用内核IO时立即返回一个状态或者数据，用户线程一直处于忙的状态

- I/O的同步和异步：用户线程调用内核IO操作时结果的返回方式
    * 同步：用户线程发起IO请求后需要等待或者轮训内核IO操作完成之后才能继续执行
    * 异步：用户发起IO请求后仍继续执行，当内核IO操作完成之后会通知用户线程，或者调用用户线程注册的回调函数

- IO同步和异步的区别就是：看向用户程序通知的是IO就绪事件还是IO完成事件

- IO复用
    * 单个线程对应多个IO，将需要处理的IO加入工作队列中，然后在工作队列中进行处理
    * 缺：适用于请求执行时间较短的IO

- 多进程：
    * 多进程同步：fastcgi:。。。。；会造成惊群现象
    * 多进程异步：Nginx：每一个进程有一个IO复用，每个进程绑定一个内核
    * 每请求一个进程：Apache

- 线程：
    * 单线程同步：NTP
    * 多线程同步：
        * 线程多在切换的时候浪费时间
        * 会加锁，导致性能下降
    * 半同步和半异步：Netty
        * 主线程吧任务放在请求中
    * 半同步半反应堆
    * Reactor:同步IO：IO复用：请求->队列-> 线程
    * Proactor:异步IO
    * 领导者追随者
        * 思想：线程池中有一个领导者和若干个追随者。每次都是领导者接收到请求，然后指定一个追随者成为新的领导者，自己去执行任务。
        * 缺点：线程池只能执行同一个任务
    